





market_agent/
├── infrastructure/
│   ├── __init__.py
│   ├── circuit_breaker.py
│   ├── health_check.py
│   └── queue_manager.py
├── input_collection/
│   ├── __init__.py
│   ├── cli_layer.py
│   ├── data_collector.py
│   ├── fundamental_parser.py
│   ├── geo_macro_context.py
│   ├── news_llm_analyzer.py
│   ├── technical_analyzer.py
│   └── top_traders_tracker.py
├── processing_analysis/
│   ├── __init__.py
│   ├── correlation_engine.py
│   ├── llm_adapter.py
│   ├── pre_filter.py
│   ├── risk_manager.py
│   ├── scoring_engine.py
│   ├── sentiment_pattern_learner.py
│   ├── signal_predictor.py
│   ├── strategy_engine.py
│   └── tie_breaker.py
├── security/
│   ├── __init__.py
│   ├── audit_log.py
│   └── secrets_manager.py
├── monitoring_feedback/
│   ├── __init__.py
│   ├── backtest_engine.py
│   ├── performance_monitor.py
│   ├── portfolio_memory.py
│   └── reporter.py
├── decision_execution/
│   ├── __init__.py
│   ├── ibkr_trading.py
│   ├── tax_reporter.py
│   └── trade_decision_engine.py
├── main.py
└── requirements.txt




# Мой пошаговый туториал по созданию Market Agent

Этот файл - моя личная документация по проекту. Здесь я записываю объяснения каждого шага, логику работы каждого модуля и описание кода.

---
---

## Шаг 0: Подготовка рабочего места

**Цель:** Настроить профессиональную среду для разработки.
**Действия:** Установка Python и VS Code, создание папки проекта и виртуального окружения `venv`. Активация окружения.
**Ключевая идея:** Виртуальное окружение изолирует зависимости нашего проекта, что является стандартом профессиональной разработки.

---
---

## Шаг 1: Сбор данных (Input & Collection)

**Цель:** Научить бота "видеть" мир, получая данные из интернета.
**Действия:** Создали папку `input_collection` и файл `data_collector.py`. Установили библиотеки `requests` и `aiohttp`. Написали класс `DataCollector`.
**Ключевая идея:** Инкапсуляция. Модуль прячет внутри себя сложную логику, предоставляя простой интерфейс для других частей программы.

---
---

## Шаг 2: Первая обработка и анализ (Processing & Analysis)

**Цель:** Научить бота "думать" — превращать сырые данные в осмысленную информацию (расчет RSI).
**Действия:** Создали папку `processing_analysis` и файл `technical_analyzer.py`. Установили `pandas` и `numpy`. Написали класс `TechnicalAnalyzer`.
**Ключевая идея (Аналогия с шеф-поваром):** Библиотеки, как `pandas`, — это не "умные" аналитики, а мощные, но послушные инструменты (как кухонный комбайн). Всю логику анализа (рецепт) задаем мы, программисты, а библиотеки лишь эффективно исполняют наши команды.

---
---

## Шаг 3: Генерация торговой идеи (Strategy Engine)

**Цель:** Изолировать логику принятия решений от логики расчетов.
**Действия:** В папке `processing_analysis` создали `strategy_engine.py`. Написали класс `StrategyEngine`, который принимает результаты анализа и выдает четкий сигнал: `BUY`, `SELL` или `HOLD`.
**Ключевая идея (Принцип разделения обязанностей):** Мы разделили код на логические блоки. `TechnicalAnalyzer` только считает, а `StrategyEngine` только решает. Это делает код чистым, понятным и легко расширяемым.

---
---

## Шаг 3.5: Важное исправление — Ошибки `ModuleNotFoundError` и `IndentationError`

На этом этапе мы столкнулись с двумя классическими ошибками Python и научились их исправлять.

1.  **`ModuleNotFoundError` (Модуль не найден):**
    *   **Проблема:** Python не мог найти наши модули, так как не считал наши папки "пакетами" с кодом и/или мы сохранили файл не в том месте.
    *   **Решение:** Мы создали пустой файл `__init__.py` в каждой папке с кодом, что "зарегистрировало" их как пакеты. Мы также убедились, что все `.py` файлы находятся в своих логических папках.

2.  **`IndentationError` (Ошибка отступа):**
    *   **Проблема:** Python использует отступы (пробелы) для определения структуры кода. Случайный лишний или отсутствующий пробел ломает программу.
    *   **Решение:** Мы полностью заменили код в файле с ошибкой на заведомо правильный шаблон, чтобы гарантировать корректность всех отступов.

---
---

## Шаг 4: Принятие и исполнение решения (Decision & Execution)

**Цель:** Научить бота "действовать" — взять финальный сигнал и превратить его в симуляцию торговой сделки.
**Действия:** Создали папку `decision_execution` и написали `TradeDecisionEngine` (формирует приказ) и `IbkrTraderSimulator` (имитирует отправку брокеру).
**Ключевая идея:** Симуляция — ключевой прием для безопасной разработки. Мы создали полный каркас работы бота от входа до выхода, не рискуя реальными деньгами.

---
---

## Шаг 5: Управление рисками (Risk Manager)

**Цель:** Превратить наивного бота в более профессионального, внедрив управление капиталом.
**Действия:** Создали `risk_manager.py` и интегрировали его в нашу систему.
**Ключевая идея (Контроль потерь):** Успешный трейдинг — это в первую очередь управление рисками. Мы реализовали важнейшую логику расчета размера позиции, которая гарантирует, что в каждой сделке бот рискует только небольшим, заранее определенным процентом от своего капитала. Это защищает его от катастрофических убытков.

---
---

## Шаг 6: Логирование и обратная связь (Monitoring & Feedback)

**Цель:** Дать боту "память". Создать "бортовой журнал" для записи всех его действий.

**Что мы сделали:**
1.  **Создали структуру:** `monitoring_feedback/reporter.py`.
2.  **Использовали библиотеку `logging`:** Это стандартный, мощный инструмент Python для ведения журналов.
3.  **Настроили логгер:** В `reporter.py` мы настроили `logging.basicConfig`, чтобы все сообщения уровня `INFO` и выше записывались в файл `trade_history.log` в определенном формате.
4.  **Интегрировали в `main.py`:** Добавили финальный шаг, на котором вызывается `Reporter` для записи информации о совершенной сделке.

---
### **Глубокое погружение: Почему `logging` лучше, чем `print`?**

Может показаться, что мы могли бы просто использовать `print()` и направлять вывод в файл. Однако `logging` гораздо мощнее:

*   **Уровни серьезности:** Вы можете помечать сообщения (`DEBUG`, `INFO`, `WARNING`, `ERROR`). В будущем можно будет легко настроить систему так, чтобы в файл писались только ошибки (`ERROR`), а на консоль выводилась вся информация (`INFO`).
*   **Форматирование:** `logging` позволяет легко добавлять к каждому сообщению важную информацию: точное время, имя модуля, где произошло событие, и т.д.
*   **Гибкость вывода:** Одно и то же сообщение можно одновременно направить в файл, в консоль, отправить по сети или по почте.
*   **Производительность:** В готовой системе можно отключить все логи ниже уровня `WARNING` одной строчкой, и программа даже не будет тратить время на формирование этих сообщений, что делает ее быстрее.

**Ключевая идея:** Мы создали основу для обратной связи. Теперь у нас есть исторические данные о работе бота, которые в будущем можно будет использовать для анализа его эффективности и поиска ошибок.

# Мой пошаговый туториал по созданию Market Agent

Этот файл - моя личная документация по проекту. Здесь я записываю объяснения каждого шага, логику работы каждого модуля и описание кода.

---
---

## Шаги 0-6: Создание каркаса бота

Мы прошли путь от идеи до создания полноценного каркаса бота, который умеет:
-   Собирать данные (`DataCollector`).
-   Анализировать их, считая индикаторы (`TechnicalAnalyzer`).
-   Применять стратегии для получения сигналов (`StrategyEngine`).
-   Формировать торговые приказы (`TradeDecisionEngine`).
-   Управлять рисками, рассчитывая размер позиции и стопы (`RiskManager`).
-   Вести "бортовой журнал" сделок в файл (`Reporter`).

---
---

## Шаг 7: Оживление бота и сканирование рынка

**Цель:** Перейти от тестовых данных к реальным и научить бота анализировать не одну, а несколько акций за один запуск.
**Действия:** Установили `yfinance`, обновили `DataCollector` и переписали `main.py` для работы со списком тикеров.
**Ключевая идея:** Мы подготовили наш скрипт для пакетной обработки. Теперь один его запуск выполняет осмысленную работу — сканирование небольшого сегмента рынка, после чего скрипт корректно завершается. Это идеальная подготовка для автоматического запуска по расписанию.

---
---

## Шаг 8: Профессиональная автоматизация (Планировщик)

**Цель:** Настроить автоматический, периодический запуск нашего бота без нашего участия.
**Ключевая идея:** Мы отделили логику нашего приложения от логики его запуска. Наш бот ничего не знает о расписании, он просто выполняет свою работу один раз. А операционная система, как надежный менеджер, вызывает его тогда, когда это необходимо.

---
### **Глубокое погружение: Эпопея с `venv` (Виртуальное окружение)**

На этом шаге мы столкнулись с серией проблем, которые идеально иллюстрируют важность виртуальных окружений (`venv`).

**Что такое `venv`?**
Это персональная, изолированная "кухня" для каждого вашего проекта на Python. Она содержит собственную копию `python.exe` и собственные "шкафы для ингредиентов" (библиотек). Это предотвращает конфликт версий библиотек между разными проектами.

**Наша проблема:** Изначально, на Шаге 0, `venv` не был создан. Мы пытались "открыть ключом (`activate`) несуществующую дверь".

**Наш путь к решению:**
1.  **Диагностика:** С помощью команды `ls .\venv\Scripts\` мы убедились, что папки действительно не существует.
2.  **Создание `venv`:** Командой `python -m venv venv` мы "построили" нашу изолированную кухню.
3.  **Активация `venv`:** Мы столкнулись с политикой безопасности PowerShell.
    *   Сначала мы попытались изменить ее командой `Set-ExecutionPolicy...`.
    *   Затем мы выяснили, что для PowerShell нужно вызывать специальный скрипт `Activate.ps1`.
    *   Финальная команда для входа на нашу "кухню" была: `.\venv\Scripts\Activate.ps1`. Успех был подтвержден появлением префикса `(venv)` в терминале.
4.  **Установка зависимостей:** После активации "кухня" была пуста. Мы создали файл `requirements.txt` со списком всех нужных библиотек и установили их одной командой `pip install -r requirements.txt`.

**Этот опыт — самый важный урок в курсе:** Всегда начинайте проект с создания и активации `venv`.

---
### **Финальная настройка планировщика в Windows**

После всех исправлений мы наконец настроили задачу с помощью командной строки.

**1. Получили пути:**
*   **Путь к Python:** `where python` (с активным `venv`).
*   **Путь к скрипту:** `cd` (и добавили `\main.py`).

**2. Создали задачу командой:**
`schtasks /Create /TN "TradeBotScanner" /TR "'ПУТЬ_К_PYTHON' 'ПУТЬ_К_MAIN.PY'" /SC DAILY /ST 23:05`

**3. Полезные команды для управления:**
*   Проверить статус: `schtasks /Query /TN "TradeBotScanner"`
*   Запустить для теста: `schtasks /Run /TN "TradeBotScanner"`
*   Удалить: `schtasks /Delete /TN "TradeBotScanner" /F`


# Мой пошаговый туториал по созданию Market Agent

Этот файл - моя личная документация по проекту. Здесь я записываю объяснения каждого шага, логику работы каждого модуля и описание кода. Он служит нашей "Конституцией" и базой знаний.

---
---
## Наша Философия Разработки ("Конституция")

Этот проект строится на принципах из книги **"The Pragmatic Programmer"**. Мы не просто пишем код, мы строим надежную и поддерживаемую систему.

*   **`Don't live with broken windows` (Не терпим беспорядок):** Мы исправляем "костыли" и плохой код сразу, пока они не стали большой проблемой.
*   **`DRY (Don't Repeat Yourself)` (Не повторяемся):** Мы избегаем дублирования логики, вынося ее в функции и классы.
*   **`Tracer Bullets` (Сквозной прототип):** Мы быстро создаем сквозной каркас системы (MVP), чтобы убедиться, что общая концепция работает, прежде чем углубляться в детали.
*   **`Orthogonality` (Независимость компонентов):** Мы проектируем модули так, чтобы изменение в одном не ломало другой. Наша многослойная архитектура — воплощение этого принципа.
*   **`Automate everything` (Автоматизируем всё):** Мы автоматизируем запуск (`schtasks`), бэкап (`git`) и в будущем — тестирование.
*   **`Defensive Programming` (Пишем код "в каске"):** Мы заранее предполагаем, что все сломается, и пишем код, который готов к ошибкам, неверным данным и недоступным API.

---
---
## Дорожная Карта Проекта

*   ✅ **Фаза 0: Фундамент.** Настройка среды, `venv`, Git, автоматизация запуска.
*   ✅ **Фаза 1: "Технический Трейдер" (MVP).** Реализована надежная стратегия на основе связки RSI + MACD.
*   ⏳ **Фаза 2: "Информированный Аналитик".** *[Мы находимся здесь]*
*   🔲 **Фаза 3: "AI-Powered Слушатель".**
*   🔲 **Фаза 4: "Машина Времени" (Бэктестинг).**
*   🔲 **Фаза 5: "Промышленная Надежность" (Infrastructure Layer).**

---
---
## История Проекта (Лог Изменений)

### **Шаги 0-8: Путь к автоматизации**
Мы прошли полный путь от создания "пустой папки" до полностью автоматизированной системы, которая:
1.  **Настроена профессионально:** Использует `venv` для изоляции зависимостей.
2.  **Безопасно хранится:** Весь код версионируется и бэкапится в приватном репозитории на **GitHub**.
3.  **Запускается автоматически:** Использует **Планировщик Задач Windows (`schtasks`)** для запуска по расписанию.
4.  **Сканирует рынок:** Проходит по списку тикеров, получая для них реальные данные с `yfinance`.
5.  **Принимает решения:** Использует базовую, но рабочую торговую стратегию.
6.  **Управляет риском:** Рассчитывает размер позиции и стоп-лоссы.
7.  **Ведет журнал:** Логирует все совершенные сделки в файл `trade_history.log`.

### **Шаг 9: Делаем бота умнее (RSI + MACD)**
*   **Цель:** Уйти от одного индикатора (RSI), который дает много ложных сигналов, к более надежной стратегии, требующей **подтверждения** от второго индикатора (MACD).
*   **Действия:**
    1.  **`technical_analyzer.py`:** Добавили новый метод `calculate_macd`, который не просто считает индикатор, но и определяет сам **факт пересечения** сигнальных линий ("бычий" или "медвежий" кроссовер).
    2.  **`strategy_engine.py`:** Полностью переписали логику. Теперь сигнал генерируется только при одновременном выполнении условий от обоих индикаторов (например, `RSI > 70 И Медвежий_кроссовер_MACD`).
    3.  **`main.py`:** Интегрировали новые вызовы и убедились, что оба результата передаются в движок стратегий.
*   **Результат:** **Фаза 1 завершена.** У нас есть рабочий MVP "Технического Трейдера", который принимает взвешенные, подтвержденные решения. Мы зафиксировали эту стабильную версию коммитом в GitHub.

### **Шаг 10: Добавляем фундаментальный анализ**
*   **Цель:** Начать реализацию **Фазы 2**. Научить бота "заглядывать под капот" компании, а не только смотреть на ее график.
*   **Действия:**
    1.  **Создали `input_collection/fundamental_parser.py`:** Новый модуль, отвечающий за сбор финансовых показателей.
    2.  **Использовали `yfinance`:** Написали метод `get_fundamental_data`, который с помощью `.info` из `yfinance` получает ключевые метрики (P/E, капитализация, дивиденды).
    3.  **Применили `Defensive Programming`:** Метод безопасно извлекает данные с помощью `.get()`, чтобы не сломаться, если у какой-то акции отсутствует тот или иной показатель.
    4.  **Интегрировали в `main.py`:** Добавили новый "Шаг 1.5", на котором мы **собираем и отображаем** фундаментальные данные. Мы пока не используем их для принятия решений, но мы проложили "трассирующую пулю" — убедились, что конвейер данных работает.
*   **Результат:** Бот стал "информированнее". Он теперь видит и техническую, и фундаментальную картину.